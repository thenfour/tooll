// Copyright (c) 2016 Framefield. All rights reserved.
// Released under the MIT license. (see LICENSE.txt)

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Framefield.Core
{
    public interface CodeDefinition
    {
        string LangageAbbrev { get; }
        IEnumerable<string> GetAutoGeneratedSectionIds(Rendering.IFXSourceCode fxsc, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart);
        string InitialSelectedSectionId { get; }
        string GenerateSectionCode(string sectionId, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart);
        string UpdateScript(MetaOperator metaOp, string completeCode);
    }

    public class ScriptCodeDefinition : CodeDefinition
    {
        public string LangageAbbrev { get { return "C#"; } }

        public IEnumerable<string> GetAutoGeneratedSectionIds(Rendering.IFXSourceCode fxsc, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
                return from g in _codeSectionGenerators
                       select g.Key;
        }

        public string InitialSelectedSectionId { get { return "function"; } }

        public string GenerateSectionCode(string sectionId, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            return _codeSectionGenerators[sectionId](metaOp, codeMetaOpPart);
        }

        public ScriptCodeDefinition()
        {
            _codeSectionGenerators = new Dictionary<string, CodeSectionGenerator>();
            _codeSectionGenerators["_using"] = GenerateUsings;
            _codeSectionGenerators["_outputids"] = GenerateOutputIds;
            _codeSectionGenerators["_inputids"] = GenerateInputIds;
            _codeSectionGenerators["_params"] = GenerateParams;
            _codeSectionGenerators["_setup"] = GenerateSetup;
            _codeSectionGenerators["_cleanup"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) => { return "}"; };
        }

        private string GenerateUsings(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var defaultUsings = "using System;\n" +
                                "using System.Collections.Generic;\n" +
                                "using System.Linq;\n" +
                                "using System.Text;\n" +
                                "using SharpDX;\n" +
                                "using SharpDX.Direct3D11;\n" +
                                "using SharpDX.Windows;";

            var opPartDefinitions = from opEntry in metaOp.Operators
                                    let opDefinition = opEntry.Value.Item1
                                    where opDefinition.IsBasic
                                    from opPartDefinition in opDefinition.OperatorParts
                                    select opPartDefinition.Item2;
            foreach (var supplierAssemblyOpPartDefinition in opPartDefinitions)
            {
                defaultUsings += "\n" + "using Framefield.Core.ID" + supplierAssemblyOpPartDefinition.ID.ToString().Replace('-', '_') + "; // " + supplierAssemblyOpPartDefinition.Name;
            }

            return defaultUsings;
        }

        private string GenerateOutputIds(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var lines = new List<string>();
            var outputs = metaOp.GetOrderedOutputs().ToList();
            outputs.Reverse();
            if (outputs.Count > 0)
            {
                var outputName = Utilities.AdjustOpPartNameForCode(outputs[0].Name);
                lines.Insert(0, string.Format("    {0} = {1}", outputName, outputs.Count - 1));
            }
            for (int i = 1; i < outputs.Count; ++i)
            {
                var outputName = Utilities.AdjustOpPartNameForCode(outputs[i].Name);
                lines.Insert(0, string.Format("    {0} = {1},", outputName, outputs.Count - 1 - i));
            }
            lines.Insert(0, "{");
            lines.Insert(0, "private enum OutputId");

            lines.Add("}");
            return string.Join("\n", lines);
        }

        private string GenerateInputIds(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var lines = new List<string>();
            var inputs = metaOp.GetOrderedInputs().ToList();
            inputs.Reverse();
            if (inputs.Count > 0)
            {
                var inputName = Utilities.AdjustOpPartNameForCode(inputs[0].Name);
                lines.Insert(0, string.Format("    {0} = {1}", inputName, inputs.Count - 1));
            }
            for (int i = 1; i < inputs.Count; ++i)
            {
                var inputName = Utilities.AdjustOpPartNameForCode(inputs[i].Name);
                lines.Insert(0, string.Format("    {0} = {1},", inputName, inputs.Count - 1 - i));
            }
            lines.Insert(0, "{");
            lines.Insert(0, "private enum InputId");

            lines.Add("}");
            return string.Join("\n", lines);
        }

        private string GenerateParams(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var lines = new List<string>();
            int idx = 0;

            var inputGroups = from input in metaOp.GetOrderedInputs()
                              group input by input.Name.Split(new[] { '.' })[0] into g
                              select new { Name = g.Key, Inputs = g.ToArray() };

            foreach (var group in inputGroups)
            {
                foreach (var input in group.Inputs)
                {
                    var inputName = Utilities.AdjustOpPartNameForCode(input.Name);

                    switch (input.OpPart.Type)
                    {
                        case FunctionType.Float:
                            {
                                var typeConverter = input.IsEnum ? "(int) " : string.Empty;
                                lines.Add(string.Format("var {0} = {1}inputs[(int)InputId.{0}].Eval(context).Value;", inputName, typeConverter));
                                break;
                            }
                        case FunctionType.Text:
                            lines.Add(string.Format("var {0} = inputs[(int)InputId.{0}].Eval(context).Text;", inputName));
                            break;
                        case FunctionType.Image:
                            lines.Add(string.Format("var {0} = inputs[(int)InputId.{0}].Eval(context).Image; // Needs to be checked for null!", inputName));
                            break;
                        case FunctionType.Dynamic:
                            lines.Add(string.Format("var {0} = inputs[(int)InputId.{0}].Eval(context).Dynamic;  // Needs to be checked for null!", inputName));
                            break;
                        case FunctionType.Mesh:
                            lines.Add(string.Format("var {0} = inputs[(int)InputId.{0}].Eval(context).Mesh;", inputName));
                            break;
                        case FunctionType.Generic:
                        case FunctionType.Scene:
                        default:
                            lines.Add(string.Format("var {0} = inputs[(int)InputId.{0}];", inputName));
                            break;
                    }
                    ++idx;
                }

                if (group.Inputs.Count() > 1)
                {
                    // real group -> generate specific data type object (e.g. Color4, Vector3, ...)
                    var groupName = Utilities.AdjustOpPartNameForCode(group.Name);
                    string type = string.Empty;
                    var firstInputName = group.Inputs[0].Name;
                    var extensionIndex = firstInputName.IndexOf('.') + 1;
                    var firstInputExtension = firstInputName.Substring(extensionIndex, firstInputName.Length - extensionIndex);
                    var typeSize = group.Inputs.Count().ToString();
                    if (firstInputExtension == "R")
                        type = "Color4";
                    else if (firstInputExtension == "X")
                    {
                        type = "Vector" + typeSize;
                    }
                    else if (firstInputExtension == "Width")
                    {
                        type = "Vector" + typeSize;
                    }
                    else
                    {
                        type = "Vector" + typeSize;
                    }

                    var groupLineBuilder = new StringBuilder(string.Format("var {0} = new {1}(", groupName, type));
                    foreach (var input in group.Inputs)
                    {
                        var inputName = Utilities.AdjustOpPartNameForCode(input.Name);
                        groupLineBuilder.AppendFormat("{0}, ", inputName);
                    }
                    groupLineBuilder.Remove(groupLineBuilder.Length - 2, 2); // remove last ", "
                    groupLineBuilder.Append(");");
                    lines.Add(groupLineBuilder.ToString());
                }
            }
            return string.Join("\n", lines);
        }

        private string GenerateSetup(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var lines = new List<string>();
            var metaInputOpParts = metaOp.GetOrderedInputs();
            var imageMetaInputOpParts = (from p in metaInputOpParts
                                         where p.OpPart.Type == FunctionType.Image
                                         select p).ToList();

            foreach (var input in imageMetaInputOpParts)
            {
                var inputName = Utilities.AdjustOpPartNameForCode(input.Name);
                lines.Add(string.Format("using (var {0}View = new ShaderResourceView(context.D3DDevice, {0}))",
                                        inputName));
            }

            lines.Add("{");
            lines.Add("    _effect.GetVariableByName(\"RenderTargetSize\").AsVector().Set(new Vector2(_usedViewport.Width, _usedViewport.Height));");

            var inputGroups = from input in metaInputOpParts
                              group input by input.Name.Split(new[] { '.' })[0] into g
                              select new { Name = g.Key, Inputs = g.ToArray() };

            foreach (var group in inputGroups)
            {
                var inputGroupName = Utilities.AdjustOpPartNameForCode(group.Name);

                switch (group.Inputs[0].OpPart.Type)
                {
                    case FunctionType.Float:
                        switch (group.Inputs.Length)
                        {
                            case 1:
                                lines.Add(string.Format("    _effect.GetVariableByName(\"{0}\").AsScalar().Set({0});",
                                                        inputGroupName));
                                break;
                            case 2:
                            case 3:
                            case 4:
                                string vectorParams = Utilities.AdjustOpPartNameForCode(group.Inputs[0].Name);
                                for (int i = 1; i < group.Inputs.Length; ++i)
                                {
                                    vectorParams += ", " + Utilities.AdjustOpPartNameForCode(group.Inputs[i].Name);
                                }
                                lines.Add(string.Format("    _effect.GetVariableByName(\"{0}\").AsVector().Set(new Vector{1}({2}));",
                                                        inputGroupName, group.Inputs.Length, vectorParams));
                                break;
                        }
                        break;
                    case FunctionType.Image:
                        lines.Add(string.Format("    _effect.GetVariableByName(\"{0}\").AsShaderResource().SetResource({0}View);", inputGroupName));
                        break;
                    default:
                        break;
                }
            }
            return string.Join("\n", lines);
        }

        public string UpdateScript(MetaOperator metaOp, string completeCode)
        {
            var metaOpPart = metaOp.OperatorParts[0].Item2;
            return UpdateClassNameAndNamespaceInScript(metaOpPart.ScriptNamespace, metaOp.Name, completeCode);
        }

        public static string UpdateClassNameAndNamespaceInScript(string newNamespace, string newClassName, string completeCode)
        {
            var code = UpdateClassNameInScript(completeCode, newClassName);
            code = UpdateNamespaceInScript(code, newNamespace);
            return code;
        }

        private static string UpdateClassNameInScript(string script, string className)
        {
            var classNamePattern = new Regex(@"\s(public\s+class\s+Class_([^\s]+)\s+:\s+)\b");
            var classnameMatches = classNamePattern.Matches(script);

            if (classnameMatches.Count == 1)
            {
                string newClassName = Utilities.RemoveSpecialCharacters(className, '_');
                string oldClassName = classnameMatches[0].Groups[2].Value;
                if (!oldClassName.Equals(newClassName))
                {
                    script = script.Replace(classnameMatches[0].Groups[1].Value, String.Format("public class Class_{0} : ", newClassName)); //class declaration
                    script = script.Replace(String.Format("Class_{0}()", oldClassName), String.Format("Class_{0}()", newClassName)); //c'tors
                    Logger.Debug("Updated classname declaration in script code to: Class_" + newClassName);
                }
            }
            else
            {
                Logger.Error("Classname declaration not found in script code. Is your script code corrupted?");
            }
            return script;
        }

        /**
         * Update the operator's code for defining a unique namespace and the classname.
         * This is required to prevent name-clashes after duplicating an operator definition.
         */
        private static string UpdateNamespaceInScript(string script, string newNamespace)
        {
            
            var namespaceIdPattern = new Regex(@"\s(namespace (Framefield.Core.ID\w{8}_\w{4}_\w{4}_\w{4}_\w{12}))\s");
            var matches = namespaceIdPattern.Matches(script);

            if (matches.Count == 1)
            {
                if (!matches[0].Groups[2].Value.Equals(newNamespace))
                {
                    script = script.Replace(matches[0].Groups[1].Value, "namespace " + newNamespace);
                    Logger.Debug("Updated namespace declaration in script code to: " + newNamespace);
                }
            }
            else
            {
                Logger.Error("NamespaceID not found in script code. Please Note: class names that are not unique will lead to unexpected side-effects.");
            }
            return script;
        }

        private delegate string CodeSectionGenerator(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart);
        private Dictionary<string, CodeSectionGenerator> _codeSectionGenerators;
    }


    public class ShaderCodeDefinition : CodeDefinition
    {
        public string LangageAbbrev { get { return "HLSL"; } }

    public Dictionary<string, string> CustomMappings { get; set; } = null;

    public IEnumerable<string> GetAutoGeneratedSectionIds(Rendering.IFXSourceCode fxsc, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
    {
      IEnumerable<string> ret = from g in _codeSectionGenerators
                                select g.Key;
      if (fxsc != null)
      {
        CustomMappings = fxsc.GetCustomCodeSectionMapping(0);
        if (CustomMappings != null)
        {
          return ret.Concat(CustomMappings.Keys);
        }
      }
      return ret;
    }

        public string InitialSelectedSectionId { get { return "PS"; } }

    public string GenerateSectionCode(string sectionId, MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
    {
      if (CustomMappings != null && CustomMappings.TryGetValue(sectionId, out string customVal))
      {
        return customVal;
      }
      return _codeSectionGenerators[sectionId](metaOp, codeMetaOpPart);
    }

        public ShaderCodeDefinition(Rendering.IFXSourceCode sourceCodePart)
        {
            _codeSectionGenerators = new Dictionary<string, CodeSectionGenerator>();

            var cust = sourceCodePart.GetCustomCodeSectionMapping(0);
      if (cust != null)
      {
        foreach (var kv in cust)
        {
          _codeSectionGenerators[kv.Key] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
          {
            return kv.Value;
          };
        }
      }

            Debug.WriteLine("ShaderCodeDefinition()");

            _codeSectionGenerators["_common parameters"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "float4x4 objectToWorldMatrix;\n" +
                       "float4x4 worldToCameraMatrix;\n" +
                       "float4x4 projMatrix;\n" +
                       "Texture2D txDiffuse;\n" +
                       "float2 RenderTargetSize;";
            };

            _codeSectionGenerators["_parameters"] = GenerateParameters;

            _codeSectionGenerators["_setup"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "SamplerState samLinear\n" +
                        "{\n" +
                        "    Filter = MIN_MAG_MIP_LINEAR;\n" +
                        "    AddressU = Clamp;\n" +
                        "    AddressV = Clamp;\n" +
                        "};";
            };

            _codeSectionGenerators["_declarations"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "struct VS_IN\n" +
                       "{\n" +
                       "    float4 pos : POSITION;\n" +
                       "    float2 texCoord : TEXCOORD;\n" +
                       "};\n" +
                       "\n" +
                       "struct PS_IN\n" +
                       "{\n" +
                       "    float4 pos : SV_POSITION;\n" +
                       "    float2 texCoord: TEXCOORD0;\n" +
                       "};";
            };

            _codeSectionGenerators["_GS"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "";
            };

            _codeSectionGenerators["_VS"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "PS_IN VS( VS_IN input )\n" +
                       "{\n" +
                       "    PS_IN output = (PS_IN)0;\n" +
                       "\n" +
                       "    output.pos = mul(input.pos, worldToCameraMatrix);\n" +
                       "    output.pos = mul(output.pos, projMatrix);\n" +
                       "    output.texCoord = input.texCoord;\n" +
                       "\n" +
                       "    return output;\n" +
                       "}";
            };

            _codeSectionGenerators["_technique"] = (MetaOperator metaOp, MetaOperatorPart codeMetaOpPart) =>
            {
                return "technique10 Render\n" +
                       "{\n" +
                       "    pass P0\n" +
                       "    {\n" +
                       "        SetGeometryShader( 0 );\n" +
                       "        SetVertexShader( CompileShader( vs_4_0, VS() ) );\n" +
                       "        SetPixelShader( CompileShader( ps_4_0, PS() ) );\n" +
                       "    }\n" +
                       "}";
            };
        }

        public string UpdateScript(MetaOperator metaOp, string completeCode)
        {
            return completeCode;
        }

        private string GenerateParameters(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart)
        {
            var inputGroups = from input in metaOp.GetOrderedInputs()
                              group input by input.Name.Split(new[] { '.' })[0] into g
                              select new { Name = g.Key, Inputs = g.ToArray() };

            var lines = new List<string>();
            foreach (var group in inputGroups)
            {
                var inputGroupName = Utilities.AdjustOpPartNameForCode(group.Name);

                switch (group.Inputs[0].OpPart.Type)
                {
                    case FunctionType.Float:
                        switch (group.Inputs.Length)
                        {
                            case 1:
                                lines.Add(string.Format("float {0};", inputGroupName));
                                break;
                            case 2:
                            case 3:
                            case 4:
                                lines.Add(string.Format("float{0} {1};", group.Inputs.Length, inputGroupName));
                                break;
                        }
                        break;
                    case FunctionType.Image:
                        lines.Add(string.Format("Texture2D {0};", inputGroupName));
                        break;
                    default:
                        break;
                }
            }
            return string.Join("\n", lines);
        }

        private delegate string CodeSectionGenerator(MetaOperator metaOp, MetaOperatorPart codeMetaOpPart);
        private Dictionary<string, CodeSectionGenerator> _codeSectionGenerators;
    }
}
